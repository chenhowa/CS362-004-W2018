
Title: isGameOver() does not always detect the Game is over when
        3 supply piles are empty

Class: Serious Bug

Date: Feb 23, 2018 
Reported By: Howard Chen 
Email: chenhowa@oregonstate.edu 


Product: dominion.c             Version: N/A
Platform: Linux Pop!_OS         Version: 17.10
Browser: N/A                    Version: N/A
URL: N/A 

Is it reproducible: Yes 

Description
===========
In my tests of dominion.c, I have a test that sets the supply counts
for the curse, treasure_map, and council_room to 0. Since 3 supply piles
are empty, isGameOver() should return TRUE. But it does not.


Steps to Produce/Reproduce
--------------------------
1. Obtain a valid gameState by calling initializeGame() with valid parameters.
2. Set the counts to 0 for curse, treasure_map, and council_room;
        e.g. state.supplyCount[province] = 0;
3. Call isGameOver() and examine the return value. It will be 0 (FALSE).


Expected Results
----------------
isGameOver() should return 1 (TRUE)

Actual Results
--------------
isGameOver() returns 0 (FALSE)





Title: discardCard() makes unexpected changes to the game state.

Class:
    Potentially Serious Bug

Date: Feb 23, 2018 
Reported By: Howard Chen 
Email: chenhowa@oregonstate.edu 

Product: dominion.c             Version: N/A
Platform: Linux Pop!_OS         Version: 17.10
Browser: N/A                    Version: N/A
URL: N/A 

Is it reproducible: Yes 

Description
===========
I have called discardCard under various conditions: with or without the trash
flag set, with a large hand, with a small hand, discarding the first card, or
discarding the last card. In each case, discardCard does almost everything correctly,
but makes some unexpected changes to the game.

Depending on where this unexpected change is, this bug could be serious.


Here is the output of my tests.

TESTING discardCard
****************Test 1: Trash, large hand, discard first card
PASSED...Return value is correct
PASSED...lastCard is now in position of discarded card
PASSED...player has one fewer card in hand
FAILED...No undesired changes were made to the game
****************Test 2: Trash, 1 card, discard first card
PASSED...Return value is correct
PASSED...Player's hand is now empty
FAILED...No undesired changes were made to the game
****************Test 3: Trash, large hand, discard last card
PASSED...Return value is correct
PASSED...Player's hand is now one less
FAILED...No undesired changes were made to the game
****************Test 4: Don't trash, large hand, discard first card
PASSED...Return value is correct
PASSED...handCount has decreased by 1
PASSED...lastCard has replaced discarded card
PASSED...played card count has increased by 1
PASSED...playedCards deck now has discarded card on top
FAILED...No undesired changes were made to the game
****************Test 5: Don't trash, 1 card, discard first card
PASSED...Return value is correct
PASSED...handCount has decreased by 1
PASSED...played card count has increased by 1
PASSED...playedCards deck now has discarded card on top
FAILED...No undesired changes were made to the game
****************Test 6: Don't trash, large hand, discard last card
PASSED...Return value is correct
PASSED...handCount has decreased by 1
PASSED...played card count has increased by 1
PASSED...playedCards deck now has discarded card on top
FAILED...No undesired changes were made to the game
discardCard(): WARNING: At least one test failed!

Steps to Produce/Reproduce
--------------------------
1. Initialize a valid gameState using initializeGame() with the correct parameters.
2. Clone this initial state for later comparison
3. Call discardCard with any set of dependencies, as described above in my
    test output results.
4. Make the changes to the cloned initial state as described by the specification of 
    discardCard.
5. Compare the cloned state with the state. They will not be identical.


Expected Results
----------------
    Cloned and uncloned states are identical.

Actual Results
--------------
    The two states differ.






Title: Smithy does not draw the correct number of cards.

Class: Serious Bug

Date: Feb 23, 2018 
Reported By: Howard Chen 
Email: chenhowa@oregonstate.edu 

Product: dominion.c             Version: N/A
Platform: Linux Pop!_OS         Version: 17.10
Browser: N/A                    Version: N/A
URL: N/A 

Is it reproducible: Yes 

Description
===========
Calling smithyPlay from a very typical gameState does not 
draw 3 cards, as expected. It seems to draw only 1 card.

Steps to Produce/Reproduce
--------------------------
1. Generate a normal gameState with initializeGame()
2. Set the player's deckCount to 5 cards and set the top three cards of the deck 
        to all be adventurer cards.
3. Call smithyPlay()


Expected Results
----------------
The player's hand count should increment by 3, and the top three cards of the deck 
    should be the top three cards in the player's hand. The player's deck count 
    should decrease by 3.

Actual Results
--------------
The player's hand count only increments by 1, and perhaps as a consequence,
    the top three in hand are not the top three cards of the deck. Also the player's
    deck count only decreases by 2, which is rather puzzling since the hand count 
    increased by 1.






Title: adventurerPlay() has incorrect side effects on the player's 
        deck and discard counts

Class: Serious Bug


Date: Feb 23, 2018 
Reported By: Howard Chen 
Email: chenhowa@oregonstate.edu 


Product: dominion.c             Version: N/A
Platform: Linux Pop!_OS         Version: 17.10
Browser: N/A                    Version: N/A
URL: N/A 

Is it reproducible: Yes 

Description
===========
I have called adventurerPlay under various conditions:
    1. When the top two cards in deck are treasures.
    2. When the bottom two cards in deck are treasures.
    3. When there is one treasure in the deck and one in the discard.

In the first case, the player's deck decreases by too many cards.
In the second case, when the player does not discard enough cards into discard pile
In the third case, the player does not draw enough cards from the deck.

My suspicion is that these 3 bugs are all related, since they all pertain to the 
same unit function.


Steps to Produce/Reproduce
--------------------------
To reproduce the first case from a valid gameState, set the top two cards in the deck to
be treasures; e.g. state->hand[player][state->handCount[player] - 1] = gold;
Then call adventurerPlay.

To reproduce the second case, give the player a deck of 5 cards, set the discard count to 0,
    and set the bottom two cards in the deck to be treasures;
    e.g. state->hand[player][0] = copper; Then call adventurerPlay

To reproduce the third case, give the player a deck of 5 cards and a discard of 1 card. Place a treasure at the top of the deck make the only card in the discard pile a treasure. Then call adventurerPlay.



Expected vs Actual Results
----------------
In the first case, we expect the player to have two fewer cards in the deck. Instead, he has 5 fewer cards.

In the second case, we expect the player to have discarded 3 cards into the discard pile.
Instead, he only discards 1 card.

In the third case, we expect the player to have two new cards in hand. Instead, the player 
has 4 new cards in hand.
    




Title: The council_room branch in cardEffect() does not draw the correct number of cards.

Class: Semi-serious Bug


Date: Feb 23, 2018 
Reported By: Howard Chen 
Email: chenhowa@oregonstate.edu 


Product: dominion.c             Version: N/A
Platform: Linux Pop!_OS         Version: 17.10
Browser: N/A                    Version: N/A
URL: N/A 

Is it reproducible: Yes 

Description
===========
After calling the council_room branch from cardEffect, my tests found that the player did not receive 4 extra cards in hand.


Steps to Produce/Reproduce
--------------------------
1. Set up a normal game state with initializeGame()
2. Set the number of players to 4 (MAX_PLAYERS);
3. Give each player in the game a deckCount of 4
4. Set each card in each player's deck to be an adventurer.
5. Call cardEffect(council_room, -1, -1, -1, &postState, 0, 0); 


Expected Results
----------------
The player should have 4 extra adventurer at the top of his hand.

Actual Results
--------------
The player only has 3 new adventurers at the top of his hand.





Title: minion branch of cardEffect leads to an unexpected change somewhere in gameState.    

Class: Minor Bug

Date: Feb 23, 2018 
Reported By: Howard Chen 
Email: chenhowa@oregonstate.edu 


Product: dominion.c             Version: N/A
Platform: Linux Pop!_OS         Version: 17.10
Browser: N/A                    Version: N/A
URL: N/A 

Is it reproducible: Yes 

Description
===========
From a valid gameState, I called the minion branch of cardEffect. The correct things happen
as a result. The issue is that some unexpected change happens somewhere.


Steps to Produce/Reproduce
--------------------------
1. Initialize a valid game state using initalizeGame(), with 3 players;
2. Save this initial game state.
3. Call cardEffect(minion, 1, 0, -1, &state, 0, 0);
4. Update the saved initial game state manually to execute the specification of the minion:
    * Increase initial->coins by 2.
    * Increase initial->numActions by 1
5. Compare the initial state and state using memcmp(&initial, &state, sizeof(struct gameState)).

Expected Results
----------------
Byte for byte, initial and state should be identical

Actual Results
--------------
They are not identical. Something outside the specification of minion occurred.





Title: Calling minion branch of cardEffect with Choice 2 does not correctly
    discard cards.

Class: Serious Bug

Date: Feb 23, 2018 
Reported By: Howard Chen 
Email: chenhowa@oregonstate.edu 

Product: dominion.c             Version: N/A
Platform: Linux Pop!_OS         Version: 17.10
Browser: N/A                    Version: N/A
URL: N/A 

Is it reproducible: Yes 

Description
===========
From a valid game state, I called the minion branch of cardEffect with Choice 2. I 
then checked the discard piles of every player and noticed that they were not updated
according to the minion specification.


Steps to Produce/Reproduce
--------------------------
1. Initialize a valid game with 4 players using initializeGame.
2. Give the MainPlayer
    * a hand of 3 cards, full of adventurer. 
    * a deck of 4 cards, full of smithy.
    * an empty discard.
3. Give the remaining players:
    * a deck of 4 cards, full of smithy.
    * an empty discard.
    * 1 player should have a hand of 4 adventurers.
    * 1 player should have a hand of 5 adventurers.
    * 1 player should have a hand of 6 adventurers
4. Call cardEffect(minion, 1, 0, -1, &state, 0, 0);

Expected Results
----------------
The MainPlayer's discard should now have 3 cards.
The player with 4 cards in hand should now have a discard with 4 cards.
The player with 5 cards in hand should now have a discard with 5 cards.
The player with 6 cards in hand should now have a discard with 6 cards.

Actual Results
--------------
Every player has 0 cards in their discard pile.





Title: adventurerPlay draws and discards far too many cards

Class: Serious Bug


Date: Feb 23, 2018 
Reported By: Howard Chen 
Email: chenhowa@oregonstate.edu 


Product: dominion.c             Version: N/A
Platform: Linux Pop!_OS         Version: 17.10
Browser: N/A                    Version: N/A
URL: N/A 

Is it reproducible: Yes 

Description
===========
In various randomly generated game states, calling adventurerPlay draws far
more cards than needed to draw 2 treasures into the hand, and discards too
many cards in the process



Steps to Produce/Reproduce
--------------------------
Set up the game state according to the following random generator.


    int numTests = 2000;
    // Most of this code is taken from testDrawCard.c.
    // It sets up the random tests as demonstrated in the video lecture
    int i, n, p;
    struct gameState G;
    printf ("Testing adventurer.\n");
    printf ("RANDOM TESTS.\n");
    SelectStream(2);
    PutSeed(3);       /*** USES RANDOM SEED OF 3 ****/
    for (n = 0; n < numTests; n++) {
        printf("iteration %i: ", n);
        fflush(stdout);
        for (i = 0; i < sizeof(struct gameState); i++) {
            ((char*)&G)[i] = floor(Random() * 256);
        }
        p = floor(Random() * 2);
        G.whoseTurn = p;
        G.deckCount[p] = floor(Random() * 250);
        G.discardCount[p] = floor(Random() * (250 - G.deckCount[p] + 1)); // ensure no overflow
        G.handCount[p] = floor(Random() * (MAX_HAND - 5)); //ensure no oveflow

        //Add valid cards to discard and deck
        for(i = 0; i < G.deckCount[p]; i++) {
            G.deck[p][i] = floor(Random() * treasure_map); 
        }
        for(i = 0; i < G.discardCount[p]; i++) {
            G.discard[p][i] = floor(Random() * treasure_map); 
        }
        //Make the played card count reasonable.
        G.playedCardCount = floor(Random() * (MAX_DECK - 5));

    }


For each iteration's game state G, call adventurerPlay(-1, -1, -1, G, 0, 0);

Expected Results
----------------
Calling adventurerPlay on the iteration 0 generated gameState should lead to a
handCount of 52, a deckCount of 78, and a discardCount of 39 for the player.

Calling adventurerPlay on the iteration 16 generated gameState should lead to a 
handCount of 280 and a deckCount + discardCount of 143

Calling adventurerPlay on the iteration 262 generated gameState should lead to
a handCount of 297 and a deckCount + discardCount of 16

Actual Results
--------------
Calling adventurerPlayon the 0th generated gameState leads to a 
handCount of 79, a deckCount of 41, and a discardCount of 49

Calling adventurerPlay on the iteration 16 generated gameState lead to a 
handCount of 293 and a deckCount + discardCount of 130

Calling adventurerPlay on the iteration 262 generated gameState lead to
a handCount of 302 and a deckCount + discardCount of 11





Title: smithyPlay does not correctly draw 3 cards

Class: Serious Bug


Date: Feb 23, 2018 
Reported By: Howard Chen 
Email: chenhowa@oregonstate.edu 


Product: dominion.c             Version: N/A
Platform: Linux Pop!_OS         Version: 17.10
Browser: N/A                    Version: N/A
URL: N/A 

Is it reproducible: Yes 

Description
===========
In many randomly generated game states, calling smithyPlay does not lead to
the expected results.



Steps to Produce/Reproduce
--------------------------
To reproduce, use the following random state generator code

    int numTests = 2000;
    // Most of this code is taken from testDrawCard.c.
    // It sets up the random tests as demonstrated in the video lecture
    int i, n, p;
    struct gameState G;
    printf ("Testing smithy.\n");
    printf ("RANDOM TESTS.\n");
    SelectStream(2);
    PutSeed(3);         /***** Uses seed value of 3 *****/
    for (n = 0; n < numTests; n++) {
        printf("iteration %i: ", n);
        fflush(stdout);
        for (i = 0; i < sizeof(struct gameState); i++) {
            ((char*)&G)[i] = floor(Random() * 256);
        }
        p = floor(Random() * 2);
        G.whoseTurn = p;
        G.deckCount[p] = floor(Random() * (MAX_DECK));
        G.discardCount[p] = floor(Random() * (MAX_DECK - 5 - G.deckCount[p])); // ensure no overflow
        G.handCount[p] = floor(Random() * (MAX_HAND - 5)); //ensure no oveflow

        //Add valid cards to discard and deck
        for(i = 0; i < G.deckCount[p]; i++) {
            G.deck[p][i] = floor(Random() * treasure_map); 
        }
        for(i = 0; i < G.discardCount[p]; i++) {
            G.discard[p][i] = floor(Random() * treasure_map); 
        }

        //Make the played card count reasonable.
        G.playedCardCount = floor(Random() * (MAX_DECK - 5));
    }

For each iteration's game state G, call smithyPlay(-1, -1, -1, G, 0, 0);

Expected Results
----------------
Calling smithyPlay on the iteration 0 gameState should give a handCount of 53
and a deckCount of 187

Calling smithyPlay on the iteration 50 gameState should give a handCount of
400 and a discardCount + deckCount of 344


Actual Results
--------------
calling smithyPlay on iteration 0 gameState gives a handCount of 51 and a 
deckCount of 188

Calling smithyPlay on the iteration 50 gameState should give a handCount of
398 and a discardCount + deckCount of 345




Title: The minion branch of cardEffect leads to unexpected changes for Choice
1 and incorrect discard and deck counts for all players involved.

Class: Serious Bug.


Date: Feb 23, 2018 
Reported By: Howard Chen 
Email: chenhowa@oregonstate.edu 


Product: dominion.c             Version: N/A
Platform: Linux Pop!_OS         Version: 17.10
Browser: N/A                    Version: N/A
URL: N/A 

Is it reproducible: Yes 

Description
===========
In multiple randomly generated gameStates, calling the minion effect of
cardEffect leads to incorrect post-call card counts


Steps to Produce/Reproduce
--------------------------
Use the following random state generate to generate random gameStates.

    int numTests = 2000;
    // Most of this code is taken from testDrawCard.c.
    // It sets up the random tests as demonstrated in the video lecture
    int i, n, p;
    int otherPlayer;
    int handPos;
    int choice1, choice2;
    struct gameState G;
    printf ("Testing minion.\n");
    printf ("RANDOM TESTS.\n");
    SelectStream(2);
    PutSeed(3);             /*********  Uses a seed value of 3!!!  **********/
    for (n = 0; n < numTests; n++) {
        printf("iteration %i: ", n);
        fflush(stdout);
        for (i = 0; i < sizeof(struct gameState); i++) {
            ((char*)&G)[i] = floor(Random() * 256);
        }
        p = floor(Random() * 2);
        G.whoseTurn = p;
        G.numPlayers = 2; //Set standard value of 2 to avoid any issues.
        G.deckCount[p] = floor(Random() * 50 + 1);
        G.discardCount[p] = floor(Random() * 50 + 1); // ensure no overflow
        G.handCount[p] = floor(Random() * 50 + 1); //ensure no oveflow

        G.numActions = floor(Random() * 500);
        G.coins = floor(Random() * 500);

        //Add valid cards to discard and deck
        for(i = 0; i < G.deckCount[p]; i++) {
            G.deck[p][i] = floor(Random() * treasure_map); 
        }
        for(i = 0; i < G.discardCount[p]; i++) {
            G.discard[p][i] = floor(Random() * treasure_map); 
        }

        // Choose a handPos for discarding for the player.
        handPos = floor(Random() * G.handCount[p]);

        //Choose a choice for the player. Recall that it is a binary choice.
        // between choice1 and choice 2
        choice1 = floor(Random() * 2); // 0 or 1?
        choice2 = (choice1 + 1) % 2; // Be whatever choice1 is not.  REPEAT FOR THE SECOND PLAYER
        otherPlayer = (p + 1) % 2;
        G.deckCount[otherPlayer] = floor(Random() * 50 + 1);
        G.discardCount[otherPlayer] = floor(Random() * 50 + 1); 
        G.handCount[otherPlayer] = floor(Random() * 50 + 1); 
        for(i = 0; i < G.deckCount[otherPlayer]; i++) {
            G.deck[otherPlayer][i] = floor(Random() * treasure_map); 
        }
        for(i = 0; i < G.discardCount[otherPlayer]; i++) {
            G.discard[otherPlayer][i] = floor(Random() * treasure_map); 
        }
        G.playedCardCount = floor(Random() * 12 );
        
        G.whoseTurn = p;
    }

For each iteration's game state G, call cardEffect(minion, choice1, choice2, -1, G, handPos, 0);


Expected Results
----------------
Calling cardEffect's minion branch on the iteration 2 gameState should give
the player a combined discardCount + deckCount = 77, which is simply the 
precall state's discardCount + deckCount + handCount - 4, since the player
simply discards his hand and draws 4 cards.

Similarly, calling cardEffect's minion branch on the iteration 2 gameState should give
the OTHER player a combined discardCount + deckCount = 89.


Actual Results
--------------
Calling cardEffect's minion branch on the iteration 2 gameState gives the
player a combined discardCount + deckCount = 33.

Calling cardEffect's minion branch on the iteration 2 gameState gives the
OTHER player a combined discardCount + deckCount = 57.

